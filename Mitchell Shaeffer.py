# -*- coding: utf-8 -*-
"""Trabalho parte 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZyCAkr7POiyHoo7FKeduhVQuN3sWuW1S
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
import random
import ap_features as apf


#Algumas constantes que serão importantes
#Mitchell Shaeffer
vgate = 0.13
tauopen = 120 #ms
tauclose = 180 #ms
tout =  6  #ms
tin = 0.3 #ms
vstim = 0.1 #ms
Cm = 10**-2
beta = 6.41025641*(10**5) #Razão volume superfície

""" #Hodgkin-Huxley
gNa = 120
gK  = 40
gL  = 0.3
Cm  = 0.2
V_K = -80
V_Na= 50
V_L = -75  """

umacelula = []
tempos = []
gates = []

def TDMASolve(a, b, c, d):
  nmax = len(d)#n em números é linhass

  # Modifica o primeiro coeficiente de cada linha
  c[0] /= b[0] #Risco de divisão por zero.
  d[0] /= b[0]

  for i in range(1, nmax):
    ptemp = b[i] - (a[i] * c[i-1])
    c[i] /= ptemp
    d[i] = (d[i] - a[i] * d[i-1])/ptemp

  #Substituição de volta
  x = [0 for i in range(nmax)]
  x[-1] = d[-1]
  for i in range(-2,-nmax-1,-1):
    x[i] = d[i] - c[i] * x[i+1]
  return x


#Função que resolve um passo de tempo no método Mitchell Shaeffer utilizando ADI para a difusão
def ADI_step_MS(uy, ux, dt, sigma, t):

  gatefactor[:,:] = dt*((uy[:,:]<vgate)*((1 - gatefactor[:,:])/tauopen) + (uy[:,:]>vgate)*(-gatefactor[:,:]/tauclose)) + gatefactor[:,:]
  Istim = np.zeros((nel+1, nel+1), dtype=np.float64)

  #ÚNICO ESTÍMULO NO INÍCIO
  """ if(0.5 < t < 0.7):
    Istim[2:nel-1,2] = vstim
  """
  #SEGUNDO ESTÍMULO PARA TENTAR CAUSAR ARRITMIA
  """ if(320.0 < t < 320.2):
    Istim[int(nel/2), 2:int(nel/2)] = vstim   """

  if(0.0 < t < 0.1):
    Istim[2:nel-1, 2] = vstim

  if(360 < t < 360.1):
    Istim[2:nel-1, 2] = vstim

  if(720 < t < 720.1):
    Istim[2:nel-1, 2] = vstim

  if(1080 < t < 1080.1):
    Istim[2:nel-1, 2] = vstim

  if(1440 < t < 1440.1):
    Istim[2:nel-1, 2] = vstim

  if(1800 < t < 1800.1):
    Istim[2:nel-1, 2] = vstim

  if(2160 < t < 2160.1):
    Istim[2:nel-1, 2] = vstim

  if(2520 < t < 2520.1):
    Istim[2:nel-1, 2] = vstim  
  
  if(2800 < t < 2800.1):
    Istim[2:nel-1, 2] = vstim
    
  #### PRIMEIRO PASSO ####
  ux[0,:]   = ux[1,:]
  ux[nel,:] = ux[nel-1,:]
  ux[:,0]   = ux[:,1]
  ux[:,nel] = ux[:,nel-1]
   
  for j in range(1,nel):
     #construcao da matriz tridiagonal
    a = np.ones(nel-1, dtype=np.float64) * (-sigma[1:nel,j-1]/2)
    b = np.ones(nel-1, dtype=np.float64) * (1+sigma[1:nel,j])
    c = np.ones(nel-1, dtype=np.float64) * (-sigma[1:nel,j+1]/2)
    # construcao do vetor fonte
    #Difusão em dy
    d = (1 - sigma[1:nel,j])*uy[1:nel,j] + sigma[1:nel,j]/2*(uy[1:nel,j+1] + uy[1:nel,j-1])
    #Termo reativo
    d += ((dt/2)/Cm)*(gatefactor[1:nel, j]*((1-uy[1:nel,j])*uy[1:nel,j]**2)/tin - uy[1:nel, j]/tout) + Istim[1:nel, j]


    # contribuicao das condicoes de contorno no termo fonte
    #Condição de Neumann = 0
    d[0] = d[0] + sigma[0,j]/2*ux[0,j]
    d[nel-2] = d[nel-2] + sigma[nel,j]/2*ux[nel,j] 

    ux[1:nel,j] = TDMASolve(a,b,c,d)
  
  uy[0,:]   = uy[1,:]
  uy[nel,:] = uy[nel-1,:]
  uy[:,0]   = uy[:,1]
  uy[:,nel] = uy[:,nel-1]

  #### SEGUNDO PASSO ####
  for i in range(1,nel):
    # construcao do vetor fonte
    a = np.ones(nel-1, dtype=np.float64) * (-sigma[i-1,1:nel]/2) #i-1
    b = np.ones(nel-1, dtype=np.float64) * (1+sigma[i,1:nel]) #i
    c = np.ones(nel-1, dtype=np.float64) * (-sigma[i+1,1:nel]/2) #i+1
    #Difusão em dx
    d = (1 - sigma[i,1:nel])*ux[i,1:nel] + sigma[i,1:nel]/2*(ux[i+1,1:nel] + ux[i-1,1:nel])
    #Termo reativo
    d += ((dt/2)/Cm)*(gatefactor[i, 1:nel]*((1-ux[i,1:nel])*ux[i,1:nel]**2)/tin - ux[i, 1:nel]/tout) + Istim[1:nel, j]

    # contribuicao das condicoes de contorno no termo fonte
    #Condição de Neumann = 0
    d[0] = d[0] + sigma[i,0]/2*uy[i,0]
    d[nel-2] = d[nel-2] + sigma[i,nel]/2*uy[i,nel] 
    

    uy[i,1:nel] = TDMASolve(a,b,c,d)

  
  global umacelula
  global tempos
  global gates
  gates.append(gatefactor[4,5])
  umacelula.append(uy[4,5])
  tempos.append(t)
  return uy

#Função:
def ADI_upwind(eps, xi, xf, nel, ti, tf, elevado, model):
  global uy
  global ux
  global x
  global y
  global dt
  global sigma
  global dx
  global h2
  global gatefactor
  # espaçamento entre os elementos
  dx = (xf-xi)/nel
  h2 = dx**2
  #espaçamento temporal
  dt = 0.01
  global sigma
  sigma = np.ones((nel+1, nel+1), dtype=np.float64)* 0.0125 #eps*dt/(h2*beta*Cm) 
  """ sigma[int(nel/2)-15:int(nel/2)+15,int(nel/2)-15:int(nel/2)+15] /= 3 """
  # sigma_ = np.ones((nel+1, nel+1))
  # random.seed(10)
  # sigma = np.random.uniform(0, 0.0125, sigma_.shape)

  print(sigma[2,2])

  x = np.linspace(xi,xf,nel+1)
  y = np.linspace(xi,xf,nel+1)
  #condicao inicial
  ux = np.zeros((nel+1, nel+1), dtype=np.float64)
  uy = np.zeros((nel+1, nel+1), dtype=np.float64)

  gatefactor = np.ones((nel+1, nel+1), dtype=np.float64)
  
  global n
  global m
  global h
  #Hodgkin-Huxley
  n = np.zeros((nel+1, nel+1), dtype=np.float64)
  m = np.zeros((nel+1, nel+1), dtype=np.float64)
  h = np.ones((nel+1, nel+1), dtype=np.float64)

  
  
  """ t = ti
  fig, ax = plt.subplots()
  ani = FuncAnimation(fig, ADI_step, frames=range(50000), repeat=False, blit=False)
  plt.show() """
  t = 0 
  i = 0
  while(t < tf):
    uy = model(uy, ux,dt, sigma, t)
    i+=1
    t = t + dt
    """ if((i > 500 and 0 < t)): #(i>10 and t<2) or (i > 10 and 350 < t < 360)  or (i > 10 and 700 < t < 710) or  or i > 10000 
      img = plt.imshow(uy, extent=(x.min(), x.max(), y.min(), y.max()) , origin='lower', cmap="coolwarm")
      img.set_clim(vmin=-0, vmax=1)
      # plt.colorbar() 
      plt.savefig(str(t) + ".png")
      print(str(100*t/tf) + "%")
      i = 0 """
    
    if(i>1000):
      print(str(100*t/tf) + "%")
      i = 0

  global tempos
  global umacelula
  global gates

  return uy, x, y

"""#Primeira Questão"""

#Parâmetros
nel = 64

# dominio espacial
xi = 0
xf = 20000
#dominio temporal
ti = 0
tf = 3000 #ms 
#coeficiente difusivo
eps = 70
#eps = 0.1

erros = []
npoints = []

for i in range(6,7):
  nel = 2**i
  print(nel)
  npoints.append(nel)
  uy,x,y = ADI_upwind(nel=nel, xi=xi, xf=xf, tf=tf, ti=ti, eps=eps, elevado=1, model=ADI_step_MS)

  """ img = plt.imshow(uy, extent=(x.min(), x.max(), y.min(), y.max()) , origin='lower', cmap="coolwarm")
  img.set_clim(vmin=0, vmax=1)
  plt.colorbar() 
  plt.show() """

  """ #Plota o gráfico de uma célula
  plt.plot(tempos, gates, color="g", label="h")
  plt.legend()
  plt.xlabel("Tempo (ms)")
  plt.ylabel("h")
  plt.show()
  plt.plot(tempos, umacelula, color="b", label="V")
  plt.legend()
  plt.xlabel("Tempo (ms)")
  plt.ylabel("v")
  #plt.ylim(-90, 50)
  plt.show()   """


  #Função utilizada para o cálculo do APD para construção de curva de restituição
  trace = apf.Beats(y=umacelula, t=tempos)
  beats = trace.beats
  beat = beats[-1]
  print(beat.apd(80))
  